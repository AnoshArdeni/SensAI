{"problem": {"title": "Two Sum II \u2014 Input Array Is Sorted", "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.", "code": "# user started with naive approach\nfrom typing import List\n\ndef two_sum(numbers: List[int], target: int) -> List[int]:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if numbers[i] + numbers[j] == target:\n                return [i+1, j+1]\n    return []\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Two Sum II \u2014 Input Array Is Sorted", "description": "Same as above \u2014 produce the next step code in Python using two pointers.", "code": "from typing import List\n\ndef two_sum(numbers: List[int], target: int) -> List[int]:\n    # TODO: improve from O(n^2) to O(n)\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Longest Substring Without Repeating Characters", "description": "Return the length of the longest substring without repeating characters.", "code": "def lengthOfLongestSubstring(s: str) -> int:\n    # current attempt: resets on any repeat -> wrong\n    seen = set()\n    best = 0\n    cur = 0\n    for ch in s:\n        if ch in seen:\n            seen.clear()\n            cur = 0\n        seen.add(ch)\n        cur += 1\n        best = max(best, cur)\n    return best\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Longest Substring Without Repeating Characters", "description": "Return the length of the longest substring without repeating characters.", "code": "def lengthOfLongestSubstring(s: str) -> int:\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Search in Rotated Sorted Array", "description": "Find target in a rotated sorted array; return index or -1.", "code": "def search(nums, target):\n    # I tried linear scan for now\n    for i, x in enumerate(nums):\n        if x == target:\n            return i\n    return -1\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Search in Rotated Sorted Array", "description": "Same as above; write binary search solution.", "code": "def search(nums, target):\n    # TODO binary search in rotated array\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Number of Islands", "description": "Count connected components of '1's in a grid (4-directional).", "code": "from collections import deque\n\ndef numIslands(grid):\n    # DFS might TLE? I'm unsure about visited handling.\n    return 0\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Number of Islands", "description": "Write either BFS or DFS; avoid revisiting cells.", "code": "def numIslands(grid):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Coin Change", "description": "Given coins and amount, return fewest coins. If impossible, return -1.", "code": "def coinChange(coins, amount):\n    # recursive without memo -> slow\n    def dfs(rem):\n        if rem == 0: return 0\n        ans = 10**9\n        for c in coins:\n            if rem - c >= 0:\n                ans = min(ans, 1 + dfs(rem-c))\n        return ans\n    res = dfs(amount)\n    return res if res < 10**9 else -1\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Coin Change", "description": "Bottom-up DP or top-down memoized approach.", "code": "def coinChange(coins, amount):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Subsets", "description": "Return all subsets of the given array of unique integers.", "code": "def subsets(nums):\n    # tries to mutate one list, ends up reusing same ref\n    out = [[]]\n    buf = []\n    for x in nums:\n        buf.append(x)\n        out.append(buf)\n    return out\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Subsets", "description": "Use backtracking; avoid shared-list pitfalls.", "code": "def subsets(nums):\n    # TODO backtracking\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Kth Largest Element in a Stream", "description": "Design a class that finds the kth largest element after each insertion.", "code": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n        self.k = k\n        self.h = []\n        # missing: building min-heap of size k\n    def add(self, val: int) -> int:\n        # naive: push and sort every time\n        self.h.append(val)\n        self.h.sort()\n        return self.h[-self.k]\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Kth Largest Element in a Stream", "description": "Implement with a size-k min-heap.", "code": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n        # TODO\n        pass\n    def add(self, val: int) -> int:\n        # TODO\n        pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Merge Intervals", "description": "Given an array of intervals, merge all overlapping intervals.", "code": "def merge(intervals):\n    # Sorting by end breaks some cases\n    intervals.sort(key=lambda x: x[1])\n    merged = []\n    for s,e in intervals:\n        if not merged or merged[-1][1] < s:\n            merged.append([s,e])\n        else:\n            merged[-1][1] = e\n    return merged\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Merge Intervals", "description": "Write correct merging (sort by start).", "code": "def merge(intervals):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Reverse Linked List", "description": "Reverse a singly-linked list iteratively.", "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseList(head):\n    # recursive only; stack overflow for long lists\n    if not head or not head.next:\n        return head\n    p = reverseList(head.next)\n    head.next.next = head\n    head.next = None\n    return p\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Reverse Linked List", "description": "Iterative reversal using O(1) extra space.", "code": "def reverseList(head):\n    # TODO iterative\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Binary Tree Level Order Traversal", "description": "Return level-order traversal of a binary tree.", "code": "from collections import deque\n\ndef levelOrder(root):\n    # uses preorder recursion -> wrong order\n    ans = []\n    def dfs(node, depth):\n        if not node: return\n        if len(ans) == depth:\n            ans.append([])\n        ans[depth].append(node.val)\n        dfs(node.left, depth+1)\n        dfs(node.right, depth+1)\n    dfs(root, 0)\n    return ans\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Binary Tree Level Order Traversal", "description": "Prefer BFS with a queue for true level order.", "code": "def levelOrder(root):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Jump Game", "description": "Given non-negative integers, determine if you can reach the last index.", "code": "def canJump(nums):\n    # attempts DP O(n^2)\n    n = len(nums)\n    dp = [False]*n\n    dp[0] = True\n    for i in range(n):\n        if dp[i]:\n            for j in range(1, nums[i]+1):\n                if i+j < n:\n                    dp[i+j] = True\n    return dp[-1]\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Jump Game", "description": "Use greedy farthest reach.", "code": "def canJump(nums):\n    # TODO greedy\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Single Number", "description": "Every element appears twice except for one. Find that one.", "code": "def singleNumber(nums):\n    # uses dict; ask for bitwise solution\n    d = {}\n    for x in nums:\n        d[x] = d.get(x, 0) + 1\n    for k,v in d.items():\n        if v == 1:\n            return k\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Single Number", "description": "Use XOR reduction.", "code": "def singleNumber(nums):\n    # TODO xor\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Redundant Connection", "description": "Given a tree with one extra edge, return that edge.", "code": "def findRedundantConnection(edges):\n    # brute force remove edge and test connectivity \u2014 too slow\n    return edges[-1]\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Redundant Connection", "description": "Implement DSU/Union-Find.", "code": "def findRedundantConnection(edges):\n    # TODO DSU\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Implement Trie (Prefix Tree)", "description": "Design insert, search, startsWith.", "code": "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word: str) -> None:\n        # stores whole word at root \u2014 wrong\n        self.root[word] = True\n    def search(self, word: str) -> bool:\n        return word in self.root\n    def startsWith(self, prefix: str) -> bool:\n        return any(k.startswith(prefix) for k in self.root)\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Implement Trie (Prefix Tree)", "description": "Node-based trie with dict children and end flag.", "code": "class Trie:\n    # TODO proper trie node\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "LRU Cache", "description": "Design a data structure that supports get and put in O(1).", "code": "class LRUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.d = {}\n        self.age = []  # list used as queue \u2014 O(n)\n    def get(self, key: int) -> int:\n        if key not in self.d:\n            return -1\n        self.age.append(key)\n        return self.d[key]\n    def put(self, key: int, value: int) -> None:\n        if len(self.d) >= self.cap and key not in self.d:\n            # pops oldest by index 0 every time \u2014 O(n)\n            oldest = self.age.pop(0) if self.age else None\n            if oldest in self.d:\n                del self.d[oldest]\n        self.d[key] = value\n        self.age.append(key)\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "LRU Cache", "description": "Use OrderedDict or hash map + doubly-linked list.", "code": "class LRUCache:\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Rotate Image", "description": "Rotate an n x n 2D matrix by 90 degrees (clockwise) in-place.", "code": "def rotate(matrix):\n    # Tried copying to new matrix -> O(n^2) extra space\n    n = len(matrix)\n    new_mat = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            new_mat[j][n-1-i] = matrix[i][j]\n    matrix[:] = new_mat\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Rotate Image", "description": "Rotate an n x n 2D matrix by 90 degrees (clockwise) in-place.", "code": "def rotate(matrix):\n    # TODO in-place\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Valid Palindrome", "description": "Determine if a string is a palindrome, considering only alphanumeric characters and ignoring cases.", "code": "def isPalindrome(s: str) -> bool:\n    # Uses reversed string directly without cleaning non-alphanum\n    return s.lower() == s.lower()[::-1]\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Valid Palindrome", "description": "Implement with two pointers, skipping non-alphanumerics.", "code": "def isPalindrome(s: str) -> bool:\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Min Stack", "description": "Design a stack that supports push, pop, top, and retrieving the minimum in O(1).", "code": "class MinStack:\n    def __init__(self):\n        self.s = []\n    def push(self, val: int) -> None:\n        self.s.append(val)\n    def pop(self) -> None:\n        self.s.pop()\n    def top(self) -> int:\n        return self.s[-1]\n    def getMin(self) -> int:\n        return min(self.s)  # O(n)\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Min Stack", "description": "Track min in O(1) with auxiliary stack.", "code": "class MinStack:\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Pow(x, n)", "description": "Implement pow(x, n), which calculates x raised to the power n (n can be negative).", "code": "def myPow(x: float, n: int) -> float:\n    # naive loop O(|n|)\n    res = 1\n    for _ in range(abs(n)):\n        res *= x\n    return res if n >= 0 else 1/res\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Pow(x, n)", "description": "Implement fast power recursion with O(log n) complexity.", "code": "def myPow(x: float, n: int) -> float:\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Sqrt(x)", "description": "Compute and return the square root of x, rounded down to the nearest integer.", "code": "def mySqrt(x: int) -> int:\n    # used math.sqrt (not allowed)\n    import math\n    return int(math.sqrt(x))\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Sqrt(x)", "description": "Use binary search to find the integer square root.", "code": "def mySqrt(x: int) -> int:\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Group Anagrams", "description": "Group the given list of strings into anagrams.", "code": "def groupAnagrams(strs):\n    # O(n^2) compare each pair\n    groups = []\n    for w in strs:\n        placed = False\n        for g in groups:\n            if sorted(w) == sorted(g[0]):\n                g.append(w)\n                placed = True\n                break\n        if not placed:\n            groups.append([w])\n    return groups\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Group Anagrams", "description": "Use a hash map with sorted word as key.", "code": "def groupAnagrams(strs):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Course Schedule", "description": "Return true if you can finish all courses given prerequisites.", "code": "def canFinish(numCourses, prerequisites):\n    # builds indegree but never enqueues zero-degree nodes\n    from collections import defaultdict\n    g = defaultdict(list)\n    indeg = [0]*numCourses\n    for a,b in prerequisites:\n        g[b].append(a)\n        indeg[a]+=1\n    # missing: queue + Kahn\n    return sum(indeg)==0\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Course Schedule", "description": "Use Kahn's algorithm (BFS topological sort).", "code": "def canFinish(numCourses, prerequisites):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Minimum Window Substring", "description": "Find the minimum window in s that contains all chars of t.", "code": "def minWindow(s: str, t: str) -> str:\n    # expands window but never shrinks\n    need = {}\n    for ch in t:\n        need[ch] = need.get(ch,0)+1\n    have = {}\n    best = \"\"\n    l=0\n    for r,ch in enumerate(s):\n        have[ch]=have.get(ch,0)+1\n        # missing shrinking loop & formed counter\n    return best\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Minimum Window Substring", "description": "Return the shortest substring of s that contains all characters of t.", "code": "def minWindow(s: str, t: str) -> str:\n    # TODO sliding window with counts and formed\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Decode Ways", "description": "Given a string s, return the number of ways to decode it.", "code": "def numDecodings(s: str) -> int:\n    # counts substrings equal to <=26 only, ignores zeros rules\n    n=len(s)\n    cnt=0\n    for i in range(n):\n        for j in range(i+1,n+1):\n            if 1<=int(s[i:j])<=26:\n                cnt+=1\n    return cnt\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Decode Ways", "description": "DP with handling of '0' and pairs 10..26.", "code": "def numDecodings(s: str) -> int:\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Edit Distance", "description": "Compute Levenshtein distance between two strings.", "code": "def minDistance(w1: str, w2: str) -> int:\n    # greedy mismatch count \u2014 incorrect\n    i=j=0\n    edits=0\n    while i<len(w1) and j<len(w2):\n        if w1[i]!=w2[j]:\n            edits+=1\n        i+=1; j+=1\n    edits+=abs((len(w1)-i)-(len(w2)-j))\n    return edits\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Edit Distance", "description": "Classic DP over prefixes with insert/delete/replace.", "code": "def minDistance(w1: str, w2: str) -> int:\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Daily Temperatures", "description": "For each day, tell how many days until a warmer temp.", "code": "def dailyTemperatures(T):\n    # nested loops O(n^2)\n    n=len(T)\n    ans=[0]*n\n    for i in range(n):\n        for j in range(i+1,n):\n            if T[j]>T[i]:\n                ans[i]=j-i\n                break\n    return ans\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Daily Temperatures", "description": "Use a monotonic decreasing stack of indices.", "code": "def dailyTemperatures(T):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Largest Rectangle in Histogram", "description": "Return the area of the largest rectangle in the histogram.", "code": "def largestRectangleArea(heights):\n    # keeps only local max \u2014 incorrect\n    best=0\n    cur=0\n    for h in heights:\n        cur=max(cur,h)\n        best=max(best,cur)\n    return best\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Largest Rectangle in Histogram", "description": "Monotonic stack with sentinel.", "code": "def largestRectangleArea(heights):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Word Ladder", "description": "Shortest transformation sequence length.", "code": "from collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    # tries DFS on words \u2014 TLE and wrong shortest path\n    seen=set([beginWord])\n    def dfs(w):\n        if w==endWord:\n            return 1\n        for nxt in wordList:\n            pass\n        return 0\n    return dfs(beginWord)\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Word Ladder", "description": "Use BFS over generic patterns or neighbors by mutation.", "code": "def ladderLength(beginWord, endWord, wordList):\n    # TODO BFS\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Network Delay Time", "description": "Shortest time for all nodes to receive signal.", "code": "def networkDelayTime(times, n, k):\n    # uses BFS on weighted graph -> wrong\n    from collections import defaultdict, deque\n    g=defaultdict(list)\n    for u,v,w in times:\n        g[u].append((v,w))\n    dist=[float('inf')]*(n+1)\n    dist[k]=0\n    q=deque([k])\n    while q:\n        u=q.popleft()\n        for v,w in g[u]:\n            if dist[u]+w<dist[v]:\n                dist[v]=dist[u]+w\n                q.append(v)\n    mx=max(dist[1:])\n    return -1 if mx==float('inf') else mx\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Network Delay Time", "description": "Use Dijkstra with a min-heap.", "code": "def networkDelayTime(times, n, k):\n    # TODO Dijkstra\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Top K Frequent Elements", "description": "Return the k most frequent elements.", "code": "def topKFrequent(nums, k):\n    # sorts entire array by frequency each time\n    freq={}\n    for x in nums:\n        freq[x]=freq.get(x,0)+1\n    return [x for x,_ in sorted(freq.items(), key=lambda it: it[1], reverse=True)[:k]]\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Top K Frequent Elements", "description": "Use heap or bucket sort for near linear time.", "code": "def topKFrequent(nums, k):\n    # TODO bucket or heap\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "House Robber II", "description": "Max money with circular houses.", "code": "def rob(nums):\n    # uses linear robber on whole array -> wrong for circular\n    def lin(a):\n        prev=curr=0\n        for x in a:\n            prev, curr = curr, max(curr, prev+x)\n        return curr\n    return lin(nums)\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "House Robber II", "description": "Run linear DP on two ranges: [0..n-2], [1..n-1].", "code": "def rob(nums):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Spiral Matrix", "description": "Return all elements of the matrix in spiral order.", "code": "def spiralOrder(matrix):\n    # boundary errors when shrinking layers\n    res=[]\n    top,left=0,0\n    bottom=len(matrix)-1\n    right=len(matrix[0])-1\n    while top<bottom and left<right:\n        for j in range(left,right): res.append(matrix[top][j])\n        for i in range(top,bottom): res.append(matrix[i][right])\n        for j in range(right,left,-1): res.append(matrix[bottom][j])\n        for i in range(bottom,top,-1): res.append(matrix[i][left])\n        top+=1;left+=1;bottom-=1;right-=1\n    return res\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Spiral Matrix", "description": "Carefully traverse while top<=bottom and left<=right.", "code": "def spiralOrder(matrix):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Product of Array Except Self", "description": "Return array where each element is product of all except itself.", "code": "def productExceptSelf(nums):\n    # divides by total product -> fails with zeros\n    prod=1\n    for x in nums:\n        prod*=x\n    return [prod//x for x in nums]\n"}, "mode": "hint", "use_evaluation": true}
{"problem": {"title": "Product of Array Except Self", "description": "Use prefix and suffix products without division.", "code": "def productExceptSelf(nums):\n    # TODO\n    pass\n"}, "mode": "hint", "use_evaluation": true}
